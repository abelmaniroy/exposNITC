breakpoint;
[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+13]=SP;
SP=[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+11]*512-1;
backup;

alias currentPID R3;
currentPID=[SYSTEM_STATUS_TABLE+1];
alias process_table_entry R4;
process_table_entry=PROCESS_TABLE+currentPID*16;
alias counter R5;
if([SYSTEM_STATUS_TABLE+5]!=0) then
	if(currentPID==15) then
		if([SYSTEM_STATUS_TABLE+5]==SWAP_OUT) then
			multipush(R3,R4);
			R1=1;
			R2=currentPID;
			call PAGER_MODULE;
			multipop(R3,R4);
			
			
		endif;
		if([SYSTEM_STATUS_TABLE+5]==SWAP_IN) then
			multipush(R3,R4);
			R1=2;
			R2=currentPID;
			call PAGER_MODULE;
			multipop(R3,R4);
			
			
		endif;
	else
		if(currentPID==1) then
			goto scheduling;
			
		endif;
	
	endif;

else
	if([SYSTEM_STATUS_TABLE+2]<MEM_LOW) then
		[SYSTEM_STATUS_TABLE+5]=SWAP_OUT;
	else
		if([SYSTEM_STATUS_TABLE+4]!=0) then
			if([SYSTEM_STATUS_TABLE+2]>MEM_HIGH) then
				[SYSTEM_STATUS_TABLE+5]=SWAP_IN;
			else
				
				counter=0;
				while(counter<16) do
					if(([PROCESS_TABLE+16*counter+6]==1)&&([PROCESS_TABLE+16*counter+0]>MAX_TICK)) then
						[SYSTEM_STATUS_TABLE+5]=SWAP_IN;
						break;
					endif;
					counter=counter+1;
				endwhile;
						
			endif;
		endif;
	endif;
	
endif;

scheduling:
[process_table_entry+4]=READY;
counter=0;
while(counter<16) do
	[PROCESS_TABLE+16*counter+0]=[PROCESS_TABLE+16*counter+0]+1;
	
	counter=counter+1;
endwhile;
call SCHEDULER;
restore;
SP=[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+13];
[PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+9]=0;
breakpoint;
ireturn;

