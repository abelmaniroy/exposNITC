
alias functionNum R1;
alias currentPID R2;
breakpoint;
if(functionNum==1) then
	alias buffNo R2;
	alias PID R3;
	while([BUFFER_TABLE+4*buffNo+2]!=-1) do
		[PROCESS_TABLE+16*PID+4]=WAIT_BUFFER;
		[PROCESS_TABLE+16*PID+5]=buffNo;
		multipush(R1,R2,R3);
		call SCHEDULER;
		multipop(R1,R2,R3);
	endwhile;
	[BUFFER_TABLE+4*buffNo+2]=PID;
	breakpoint;
	return;
	

endif;

if(functionNum==2) then
	alias buffNo R2;
	alias PID R3;
	if(PID!=[BUFFER_TABLE+4*buffNo+2]) then
		R0=-1;
		return;
	endif;
	[BUFFER_TABLE+4*buffNo+2]=-1;
	alias counter R4;
	counter=0;
	while(counter<16) do
		if(([PROCESS_TABLE+16*PID+4]==WAIT_BUFFER)&&([PROCESS_TABLE+16*PID+5]==buffNo)) then
			[PROCESS_TABLE+16*PID+4]=READY;
		endif;
		counter=counter+1;
	endwhile;
	R0=0;
	breakpoint;
	return;
	

endif;

if(functionNum==3) then
	while([DISK_STATUS_TABLE]==1) do
		[PROCESS_TABLE+currentPID*16+4]=WAIT_DISK;
		multipush(R1,R2);
		call SCHEDULER;
		multipop(R1,R2);
	endwhile;
	[DISK_STATUS_TABLE]=1;
	[DISK_STATUS_TABLE+4]=currentPID;
	
	return;
endif;

if(functionNum==4) then
	alias inodeIndex R2;
	alias PID R3;
	while([FILE_STATUS_TABLE+4*inodeIndex+0]!=-1) do
		[PROCESS_TABLE+PID*16+4]=WAIT_FILE;
		[PROCESS_TABLE+PID*16+5]=inodeIndex;
		multipush(R1,R2,R3);
		call SCHEDULER;
		multipop(R1,R2,R3);
	endwhile;
	
	if([INODE_TABLE+16*inodeIndex]==-1) then
		R0=-1;
		return;
	
	endif;
	[FILE_STATUS_TABLE+4*inodeIndex+0]=PID;
	R0=0;
	return;
	
endif;


if(functionNum==5) then
	alias inodeIndex R2;
	alias PID R3;
	if([FILE_STATUS_TABLE+4*inodeIndex+0]!=PID) then
		R0=-1;
		return;
	endif;
	[FILE_STATUS_TABLE+4*inodeIndex+0]=-1;
	alias counter R4;
	counter=0;
	while(counter<16) do
		if(([PROCESS_TABLE+16*counter+4]==WAIT_FILE)&&(([PROCESS_TABLE+16*counter+4]==inodeIndex))) then
			[PROCESS_TABLE+16*counter+4]=READY;
		endif;
		counter=counter+1;
	endwhile;
	R0=0;
	return;

endif;

if(functionNum==6) then
	breakpoint;
	alias counter R3;
	counter=0;
	while(counter<32) do
		if([SEMAPHORE_TABLE+4*counter+1]==0) then
			[SEMAPHORE_TABLE+4*counter+1]=1;
			[SEMAPHORE_TABLE+4*counter+0]=-1;
			R0=counter;
			return;
		endif;
		counter=counter+1;
	endwhile;
	R0=-1;
	return;
endif;

if(functionNum==7) then
	breakpoint;
	breakpoint;
	alias semEntry R2;
	alias PID R3;
	alias counter R4;
	if([SEMAPHORE_TABLE+4*semEntry]==PID) then
			
			[SEMAPHORE_TABLE+4*semEntry+0]=-1;
			counter=0;
			while(counter<16) do
				if(([PROCESS_TABLE+16*counter+4]==WAIT_SEMAPHORE)&&([PROCESS_TABLE+16*counter+5]==semEntry)) then
					[PROCESS_TABLE+16*counter+4]=READY;
				endif;
				
				counter=counter+1;
			endwhile;
	endif;
	[SEMAPHORE_TABLE+4*semEntry+1]=[SEMAPHORE_TABLE+4*semEntry+1]-1;
	R0=0;
	return;
endif;


if(functionNum==8) then
	while([TERMINAL_STATUS_TABLE]==1) do
		[PROCESS_TABLE+currentPID*16+4]=WAIT_TERMINAL;
		multipush(R1,R2);
		call SCHEDULER;
		multipop(R1,R2);
	endwhile;
	[TERMINAL_STATUS_TABLE]=1;
	[TERMINAL_STATUS_TABLE+1]=currentPID;
	
	return;
endif;
if (functionNum==9) then
	if(currentPID==[TERMINAL_STATUS_TABLE+1]) then
		[TERMINAL_STATUS_TABLE]=0;
		alias counter R3;
		counter=0;
		while(counter<16) do
			if([PROCESS_TABLE+16*counter+4]==WAIT_TERMINAL) then
				[PROCESS_TABLE+16*counter+4]=READY;
			endif;
			counter=counter+1;
		endwhile;
		R0=0;
		
		return;
	else
		R0=-1;
		return;
	endif;
endif;
